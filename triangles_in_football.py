# -*- coding: utf-8 -*-
"""Triangles in Football

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XOG_AkHNT6hlUTYlgyPqfYfijsiiU6V4

#Triangle Formation Prediction System Documentation
A Tactical Analysis Tool for Football Coaches & Analysts
Platform for Football Coaches & Analysts

Author: Anthony Manyura, Finalist Bsc.Mathematics and Computer Science(JKUAT)

##1. Introduction
This notebook provides a machine learning-powered tactical analysis tool that helps football coaches and analysts:

<li>Predict triangle passing patterns in build-up play

<li>Analyze team formations and their impact on triangular play

<li>Generate opponent counter-strategies to disrupt passing networks

<li>Optimize player positioning for better triangle creation

Built using Python, Scikit-learn, and Interactive Widgets, this system is designed for real-time match analysis and training optimization.

##2.Importing data and libraries
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib.patches import Polygon
import random
from scipy.spatial import Delaunay
import math

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

# Set visualization style
sns.set_style('whitegrid')
plt.rcParams['figure.figsize'] = (12, 8)

"""Synthetic Data Generation"""

def generate_team_data(team_name, num_players=11, matches=10, style_factor=1.0):
    """
    Generate synthetic passing data for a football team
    """
    data = []

    # Base values depending on team style
    if team_name == "Klopp's Liverpool 2019":
        base_diagonal = 25 * style_factor
        base_square = 15 * style_factor
        triangle_factor = 0.8
        cutback_factor = 0.7
    elif team_name == "Pep's Barcelona 2012":
        base_diagonal = 40 * style_factor
        base_square = 10 * style_factor
        triangle_factor = 1.2
        cutback_factor = 0.9
    elif team_name == "Pep's Man City 2023":
        base_diagonal = 35 * style_factor
        base_square = 20 * style_factor
        triangle_factor = 1.1
        cutback_factor = 0.8
    else:
        base_diagonal = 20 * style_factor
        base_square = 20 * style_factor
        triangle_factor = 1.0
        cutback_factor = 0.5

    # Generate player data
    for player_num in range(1, num_players + 1):
        for match in range(1, matches + 1):
            # Position-based adjustments
            if player_num <= 4:  # Defenders
                pos_factor = 0.9
                pass_length = np.random.normal(15, 5)
            elif player_num <= 8:  # Midfielders
                pos_factor = 1.2
                pass_length = np.random.normal(10, 3)
            else:  # Forwards
                pos_factor = 0.8
                pass_length = np.random.normal(12, 4)

            # Generate pass counts with some randomness
            diagonal_passes = int(max(0, np.random.normal(base_diagonal * pos_factor, 5)))
            square_passes = int(max(0, np.random.normal(base_square * pos_factor, 3)))

            # Triangles formed (related to diagonal passes)
            triangles_formed = int(diagonal_passes * triangle_factor * np.random.uniform(0.8, 1.2) / 3)

            # Calculate average angle (triangles should be ~60 deg)
            avg_angle = np.random.normal(60, 10)

            # Cutback goals (only for attacking players)
            if player_num >= 9:
                cutback_goals = int(np.random.poisson(cutback_factor * diagonal_passes / 20))
            else:
                cutback_goals = 0

            # Calculate shape efficiency metric (higher for more triangles)
            shape_efficiency = (diagonal_passes * 1.5 + square_passes) / (diagonal_passes + square_passes + 1)

            data.append({
                'Team': team_name,
                'Player': f'Player {player_num}',
                'Position': 'Defender' if player_num <=4 else ('Midfielder' if player_num <=8 else 'Forward'),
                'Match': match,
                'Diagonal Passes': diagonal_passes,
                'Square Passes': square_passes,
                'Triangles Formed': triangles_formed,
                'Avg Triangle Angle': avg_angle,
                'Avg Pass Length': pass_length,
                'Cutback Goals': cutback_goals,
                'Shape Efficiency': shape_efficiency
            })

    return pd.DataFrame(data)

# Generate data for our teams
liverpool_df = generate_team_data("Klopp's Liverpool 2019", style_factor=1.1)
barcelona_df = generate_team_data("Pep's Barcelona 2012", style_factor=1.3)
mancity_df = generate_team_data("Pep's Man City 2023", style_factor=1.2)

# Combine all data
all_teams_df = pd.concat([liverpool_df, barcelona_df, mancity_df], ignore_index=True)

# Display sample data
all_teams_df.sample(10)

"""Additional Data Fields"""

# Calculate additional metrics
all_teams_df['Total Passes'] = all_teams_df['Diagonal Passes'] + all_teams_df['Square Passes']
all_teams_df['Triangle Ratio'] = all_teams_df['Triangles Formed'] / (all_teams_df['Total Passes'] + 0.001)
all_teams_df['Diagonal Pass %'] = all_teams_df['Diagonal Passes'] / all_teams_df['Total Passes']

# Calculate theoretical triangle side length (simplified)
all_teams_df['Triangle Side Length'] = all_teams_df['Avg Pass Length'] * 1.2  # Approximation

# Display the enhanced dataframe
all_teams_df.head()

cutback_goals_df = all_teams_df[all_teams_df['Cutback Goals'] > 0]
display(cutback_goals_df)



"""#Data Analysis
 initial analysis to compare the teams' passing patterns.

## Passing and Pasees comparison

We'll compare number of passes for each team
"""

# Team-level aggregation
team_stats = all_teams_df.groupby('Team').agg({
    'Diagonal Passes': 'mean',
    'Square Passes': 'mean',
    'Triangles Formed': 'mean',
    'Triangle Ratio': 'mean',
    'Cutback Goals': 'sum',
    'Shape Efficiency': 'mean',
    'Avg Triangle Angle': 'mean'
}).reset_index()

# Display team comparisons
print("\nTeam Comparison Statistics:")
display(team_stats)

# Visualization 1: Passing Patterns
plt.figure(figsize=(14, 6))
sns.barplot(data=team_stats, x='Team', y='Diagonal Passes', color='blue', label='Diagonal Passes')
sns.barplot(data=team_stats, x='Team', y='Square Passes', color='red', label='Square Passes', alpha=0.6)
plt.title('Average Diagonal vs Square Passes per Player per Match')
plt.ylabel('Number of Passes')
plt.legend()
plt.show()

# Visualization 2: Triangle Formation Efficiency
plt.figure(figsize=(10, 6))
sns.barplot(data=team_stats, x='Team', y='Triangle Ratio', palette='viridis')
plt.title('Ratio of Triangles Formed to Total Passes')
plt.ylabel('Triangle Formation Ratio')
plt.show()

"""### Analysis and Interpretation of the Passing graphs

some visualizations to demonstrate the geometric advantages of triangles.
"""

# Function to generate and visualize passing shapes
def visualize_passing_shapes(team_name):
    team_data = all_teams_df[all_teams_df['Team'] == team_name].iloc[0]

    # Create figure
    fig, ax = plt.subplots(1, 2, figsize=(16, 6))

    # Square passing pattern
    square_vertices = np.array([[0,0], [1,0], [1,1], [0,1]])
    square = Polygon(square_vertices, closed=True, fill=False,
                    edgecolor='red', linewidth=2, label='Square Passing')
    ax[0].add_patch(square)
    ax[0].set_xlim(-0.5, 1.5)
    ax[0].set_ylim(-0.5, 1.5)
    ax[0].set_title('Square Passing Network')
    ax[0].set_aspect('equal')
    ax[0].legend()

    # Triangle passing pattern (equilateral)
    triangle_vertices = np.array([[0,0], [1,0], [0.5, np.sqrt(3)/2]])
    triangle = Polygon(triangle_vertices, closed=True, fill=False,
                      edgecolor='blue', linewidth=2, label='Triangle Passing')
    ax[1].add_patch(triangle)
    ax[1].set_xlim(-0.5, 1.5)
    ax[1].set_ylim(-0.5, 1.5)
    ax[1].set_title('Triangular Passing Network')
    ax[1].set_aspect('equal')
    ax[1].legend()

    plt.suptitle(f'Passing Shape Comparison for {team_name}', y=1.05)
    plt.show()

    # Calculate and display geometric properties
    print(f"\nGeometric Analysis for {team_name}:")
    print("Square Network:")
    print("- Fixed angles (90¬∞) make passing predictable")
    print("- Only 2 immediate passing options from any position")
    print("- Longer diagonal passes required (‚àö2 ‚âà 1.41 times side length)")

    print("\nTriangle Network:")
    print("- More acute angles (60¬∞) allow for sharper passing lanes")
    print("- 3 immediate passing options from any position")
    print("- All sides equal length, maintaining consistent passing distance")
    print("- Naturally creates more passing options and triangles")

# Visualize for each team
for team in all_teams_df['Team'].unique():
    visualize_passing_shapes(team)

"""##Advanced Analysis: Passing Networks

a more sophisticated analysis of passing networks.
"""

# Function to simulate and visualize a passing network
def simulate_passing_network(team_name, num_passes=50):
    team_data = all_teams_df[all_teams_df['Team'] == team_name]
    avg_angle = team_data['Avg Triangle Angle'].mean()
    avg_length = team_data['Avg Pass Length'].mean()

    # Generate player positions (simplified)
    positions = {
        'GK': (0, 0),
        'DEF1': (2, -1), 'DEF2': (2, 0), 'DEF3': (2, 1), 'DEF4': (2, 2),
        'MID1': (4, -1.5), 'MID2': (4, -0.5), 'MID3': (4, 0.5), 'MID4': (4, 1.5),
        'FWD1': (6, -1), 'FWD2': (6, 1)
    }

    # Create figure
    plt.figure(figsize=(12, 8))

    # Plot players
    for pos, coord in positions.items():
        plt.scatter(*coord, s=200, label=pos if pos in ['GK', 'DEF1', 'MID1', 'FWD1'] else "")
        plt.text(coord[0], coord[1]+0.2, pos, ha='center')

    # Simulate passes (more likely between nearby players)
    for _ in range(num_passes):
        sender, receiver = random.sample(list(positions.items()), 2)
        dist = math.dist(sender[1], receiver[1])

        # More likely to pass to closer players (with some randomness)
        if random.random() < 1/(dist+0.5):
            plt.plot([sender[1][0], receiver[1][0]],
                    [sender[1][1], receiver[1][1]],
                    'b-', alpha=0.4, linewidth=1)

    # Highlight some triangles
    triangles = [
        (positions['DEF2'], positions['MID2'], positions['MID3']),
        (positions['MID1'], positions['MID2'], positions['FWD1']),
        (positions['MID3'], positions['MID4'], positions['FWD2'])
    ]

    for triangle in triangles:
        tri = Polygon([triangle[0], triangle[1], triangle[2]],
                     closed=True, fill=False, edgecolor='green', linewidth=2, linestyle='--')
        plt.gca().add_patch(tri)

    plt.title(f'Simulated Passing Network for {team_name}\n(Green dashes show common triangular patterns)')
    plt.xlabel('Field Position (arbitrary units)')
    plt.ylabel('Field Position (arbitrary units)')
    plt.legend()
    plt.grid(True)
    plt.show()

# Simulate for each team
for team in all_teams_df['Team'].unique():
    simulate_passing_network(team)

"""##Statistical Comparison
statistical comparisons between the teams.
"""

from scipy import stats

# Compare triangle ratios between teams
teams = all_teams_df['Team'].unique()
results = []

for i in range(len(teams)):
    for j in range(i+1, len(teams)):
        team1 = teams[i]
        team2 = teams[j]

        data1 = all_teams_df[all_teams_df['Team'] == team1]['Triangle Ratio']
        data2 = all_teams_df[all_teams_df['Team'] == team2]['Triangle Ratio']

        t_stat, p_val = stats.ttest_ind(data1, data2)

        results.append({
            'Comparison': f"{team1} vs {team2}",
            'T-statistic': t_stat,
            'P-value': p_val,
            'Significant (p < 0.05)': p_val < 0.05
        })

# Create results dataframe
comparison_df = pd.DataFrame(results)
print("\nStatistical Comparison of Triangle Ratios Between Teams:")
display(comparison_df)

# Correlation analysis
print("\nCorrelation Between Triangle Ratio and Cutback Goals:")
corr = all_teams_df.groupby('Team')[['Triangle Ratio', 'Cutback Goals']].mean().corr()
display(corr)

plt.figure(figsize=(8, 6))
sns.scatterplot(data=all_teams_df, x='Triangle Ratio', y='Cutback Goals', hue='Team', s=100)
plt.title('Relationship Between Triangle Formation and Cutback Goals')
plt.show()



"""updated

squad names
"""

# Define real squads for each team
team_squads = {
    "Klopp's Liverpool 2019": {
        'GK': ['Alisson'],
        'DEF': ['Virgil van Dijk', 'Trent Alexander-Arnold', 'Andrew Robertson', 'Joel Matip', 'Joe Gomez'],
        'MID': ['Jordan Henderson', 'Fabinho', 'Georginio Wijnaldum', 'James Milner', 'Naby Ke√Øta', 'Alex Oxlade-Chamberlain'],
        'FWD': ['Mohamed Salah', 'Sadio Man√©', 'Roberto Firmino', 'Xherdan Shaqiri', 'Divock Origi']
    },
    "Pep's Barcelona 2012": {
        'GK': ['Victor Vald√©s'],
        'DEF': ['Dani Alves', 'Gerard Piqu√©', 'Carles Puyol', 'Javier Mascherano', 'Eric Abidal'],
        'MID': ['Xavi', 'Andr√©s Iniesta', 'Sergio Busquets', 'Cesc F√†bregas', 'Thiago Alc√¢ntara'],
        'FWD': ['Lionel Messi', 'David Villa', 'Pedro', 'Alexis S√°nchez']
    },
    "Pep's Man City 2023": {
        'GK': ['Ederson'],
        'DEF': ['Kyle Walker', 'R√∫ben Dias', 'John Stones', 'Nathan Ak√©', 'Manuel Akanji'],
        'MID': ['Rodri', 'Kevin De Bruyne', 'ƒ∞lkay G√ºndoƒüan', 'Bernardo Silva', 'Jack Grealish'],
        'FWD': ['Erling Haaland', 'Phil Foden', 'Riyad Mahrez', 'Juli√°n √Ålvarez']
    }
}

# Import necessary libraries within this cell scope if it might be run independently
import pandas as pd
import numpy as np # Explicitly import numpy here
import random

# Define real squads for each team (assuming this was run before this cell)
# team_squads = { ... } # This variable needs to be defined before calling generate_enhanced_team_data

def generate_enhanced_team_data(team_name, matches=10):
    """
    Generate enhanced passing data with real player names and position-specific patterns
    """
    data = []
    squad = team_squads[team_name]

    # Team style parameters
    if team_name == "Klopp's Liverpool 2019":
        style_params = {
            'DEF': {'diagonal': 18, 'square': 12, 'pass_length': 18},
            'MID': {'diagonal': 28, 'square': 15, 'pass_length': 12},
            'FWD': {'diagonal': 22, 'square': 10, 'pass_length': 14},
            'GK': {'diagonal': 10, 'square': 15, 'pass_length': 25},
            'triangle_factor': 0.8,
            'cutback_factor': 0.7
        }
    elif team_name == "Pep's Barcelona 2012":
        style_params = {
            'DEF': {'diagonal': 25, 'square': 8, 'pass_length': 15},
            'MID': {'diagonal': 45, 'square': 12, 'pass_length': 10},
            'FWD': {'diagonal': 30, 'square': 5, 'pass_length': 12},
            'GK': {'diagonal': 15, 'square': 10, 'pass_length': 20},
            'triangle_factor': 1.2,
            'cutback_factor': 0.9
        }
    elif team_name == "Pep's Man City 2023":
        style_params = {
            'DEF': {'diagonal': 22, 'square': 15, 'pass_length': 16},
            'MID': {'diagonal': 38, 'square': 20, 'pass_length': 11},
            'FWD': {'diagonal': 25, 'square': 12, 'pass_length': 13},
            'GK': {'diagonal': 12, 'square': 18, 'pass_length': 22},
            'triangle_factor': 1.1,
            'cutback_factor': 0.8
        }
    else:
        # Default parameters if team name not matched
        style_params = {
            'DEF': {'diagonal': 15, 'square': 10, 'pass_length': 16},
            'MID': {'diagonal': 20, 'square': 15, 'pass_length': 10},
            'FWD': {'diagonal': 18, 'square': 8, 'pass_length': 12},
            'GK': {'diagonal': 8, 'square': 12, 'pass_length': 20},
            'triangle_factor': 1.0,
            'cutback_factor': 0.5
        }


    # Generate data for each player
    for position_group, players in squad.items():
        for player in players:
            for match in range(1, matches + 1):
                params = style_params[position_group]

                # Generate pass counts with some randomness
                diagonal_passes = int(max(5, np.random.normal(params['diagonal'], 5)))
                square_passes = int(max(3, np.random.normal(params['square'], 3)))

                # Triangles formed based on diagonal passes
                triangles_formed = int(diagonal_passes * style_params['triangle_factor'] * np.random.uniform(0.8, 1.2) / 3)

                # Angle depends on position (midfielders create sharper angles)
                if position_group == 'MID':
                    avg_angle = np.random.normal(55, 5)
                else:
                    avg_angle = np.random.normal(65, 10)

                # Cutback goals (mostly for forwards and attacking mids)
                if position_group == 'FWD' or (position_group == 'MID' and player in ['Kevin De Bruyne', 'Andr√©s Iniesta']):
                    cutback_goals = int(np.random.poisson(style_params['cutback_factor'] * diagonal_passes / 15))
                else:
                    cutback_goals = 0

                # Shape efficiency metric
                shape_efficiency = (diagonal_passes * 1.5 + square_passes) / (diagonal_passes + square_passes + 1)

                data.append({
                    'Team': team_name,
                    'Player': player,
                    'Position': position_group,
                    'Match': match,
                    'Diagonal Passes': diagonal_passes,
                    'Square Passes': square_passes,
                    'Triangles Formed': triangles_formed,
                    'Avg Triangle Angle': avg_angle,
                    'Avg Pass Length': params['pass_length'] * np.random.uniform(0.9, 1.1),
                    'Cutback Goals': cutback_goals,
                    'Shape Efficiency': shape_efficiency,
                    'Key Player': 1 if player in [
                        'Virgil van Dijk', 'Trent Alexander-Arnold', 'Mohamed Salah', # Liverpool
                        'Xavi', 'Andr√©s Iniesta', 'Lionel Messi', # Barcelona
                        'Kevin De Bruyne', 'Rodri', 'Erling Haaland' # Man City
                    ] else 0
                })

    return pd.DataFrame(data)

# Generate enhanced data
enhanced_liverpool = generate_enhanced_team_data("Klopp's Liverpool 2019")
enhanced_barcelona = generate_enhanced_team_data("Pep's Barcelona 2012")
enhanced_mancity = generate_enhanced_team_data("Pep's Man City 2023")

# Combine all data
enhanced_df = pd.concat([enhanced_liverpool, enhanced_barcelona, enhanced_mancity], ignore_index=True)

# Calculate additional metrics
enhanced_df['Total Passes'] = enhanced_df['Diagonal Passes'] + enhanced_df['Square Passes']
enhanced_df['Triangle Ratio'] = enhanced_df['Triangles Formed'] / (enhanced_df['Total Passes'] + 0.001)
enhanced_df['Diagonal Pass %'] = enhanced_df['Diagonal Passes'] / enhanced_df['Total Passes']
enhanced_df['Triangle Side Length'] = enhanced_df['Avg Pass Length'] * 1.2

# Display sample
enhanced_df.sample(10)

"""##Position-Specific Analysis"""

# Position analysis
position_stats = enhanced_df.groupby(['Team', 'Position']).agg({
    'Diagonal Passes': 'mean',
    'Square Passes': 'mean',
    'Triangle Ratio': 'mean',
    'Avg Triangle Angle': 'mean'
}).reset_index()

print("\nPosition-Specific Passing Statistics:")
display(position_stats)

# Visualization
# Import matplotlib.pyplot if it's not guaranteed to be imported elsewhere
import matplotlib.pyplot as plt
import seaborn as sns # Also ensure seaborn is imported if used in the cell

plt.figure(figsize=(14, 8))
sns.barplot(data=position_stats, x='Team', y='Triangle Ratio', hue='Position', palette='coolwarm')
plt.title('Triangle Formation Ratio by Position and Team')
plt.ylabel('Triangle Ratio (Triangles Formed/Total Passes)')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""##4. Key Player Analysis"""

# Key player analysis
key_players = enhanced_df[enhanced_df['Key Player'] == 1]

print("\nKey Player Statistics:")
display(key_players.groupby(['Team', 'Player']).agg({
    'Diagonal Passes': 'mean',
    'Triangle Ratio': 'mean',
    'Cutback Goals': 'sum',
    'Shape Efficiency': 'mean'
}).sort_values('Triangle Ratio', ascending=False))

# Visualization
plt.figure(figsize=(14, 6))
sns.scatterplot(data=key_players, x='Diagonal Passes', y='Triangle Ratio',
               hue='Player', style='Team', s=200)
plt.title('Key Players: Diagonal Passes vs Triangle Formation Efficiency')
plt.xlabel('Average Diagonal Passes per Match')
plt.ylabel('Triangle Formation Ratio')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.show()

"""##5. Team-Specific Passing Networks"""

# Import necessary libraries within this cell scope if it might be run independently
import pandas as pd
import numpy as np # Explicitly import numpy here
import random
import math # Explicitly import math here

# Define real squads for each team (assuming this was run before this cell)
# team_squads = { ... } # This variable needs to be defined before calling generate_enhanced_team_data

# Rest of the code for generate_enhanced_team_data and its calls

# Define visualize_team_passing_network function
def visualize_team_passing_network(team_name):
    team_data = enhanced_df[enhanced_df['Team'] == team_name]
    key_players = team_data[team_data['Key Player'] == 1]['Player'].unique()

    # Define realistic positions based on formation
    if team_name == "Klopp's Liverpool 2019":
        # 4-3-3 formation
        positions = {
            'GK': {'Alisson': (0, 0)},
            'DEF': {
                'Trent Alexander-Arnold': (2, -2),
                'Virgil van Dijk': (2, 0),
                'Joel Matip': (2, 1.5),
                'Andrew Robertson': (2, 2)
            },
            'MID': {
                'Jordan Henderson': (4, -1),
                'Fabinho': (4, 0),
                'Georginio Wijnaldum': (4, 1)
            },
            'FWD': {
                'Mohamed Salah': (6, -2),
                'Roberto Firmino': (6, 0),
                'Sadio Man√©': (6, 2)
            }
        }
    elif team_name == "Pep's Barcelona 2012":
        # 4-3-3 with false 9
        positions = {
            'GK': {'Victor Vald√©s': (0, 0)},
            'DEF': {
                'Dani Alves': (2, -2),
                'Gerard Piqu√©': (2, -0.5),
                'Carles Puyol': (2, 0.5),
                'Eric Abidal': (2, 2)
            },
            'MID': {
                'Xavi': (4, -1),
                'Sergio Busquets': (4, 0),
                'Andr√©s Iniesta': (4, 1)
            },
            'FWD': {
                'Lionel Messi': (5, 0),  # False 9
                'Alexis S√°nchez': (6, -1.5),
                'Pedro': (6, 1.5)
            }
        }
    else:  # Man City 2023
        # Flexible 3-2-4-1
        positions = {
            'GK': {'Ederson': (0, 0)},
            'DEF': {
                'Kyle Walker': (2, -2),
                'R√∫ben Dias': (2, 0),
                'Nathan Ak√©': (2, 2)
            },
            'MID': {
                'Rodri': (3, -1),
                'John Stones': (3, 1),
                'Kevin De Bruyne': (4, -2),
                'ƒ∞lkay G√ºndoƒüan': (4, -0.5),
                'Bernardo Silva': (4, 0.5),
                'Jack Grealish': (4, 2)
            },
            'FWD': {
                'Erling Haaland': (6, 0)
            }
        }

    # Create figure
    plt.figure(figsize=(12, 8))

    # Plot all players
    for position_group, players in positions.items():
        for player, coord in players.items():
            size = 300 if player in key_players else 200
            alpha = 1.0 if player in key_players else 0.7
            plt.scatter(*coord, s=size, label=player, alpha=alpha)
            plt.text(coord[0], coord[1]+0.2, player, ha='center',
                    fontsize=9 if player not in key_players else 10,
                    fontweight='normal' if player not in key_players else 'bold')

    # Simulate passes based on actual stats
    # Select only numeric columns before calculating the mean
    numeric_cols = team_data.select_dtypes(include=np.number).columns.tolist()
    player_stats = team_data.groupby('Player')[numeric_cols].mean().reset_index()

    for _, row in player_stats.iterrows():
        if row['Player'] in positions['GK']:
            continue  # Skip GK for simplicity

        # Get player position
        sender_pos = None
        for group in positions.values():
            if row['Player'] in group:
                sender_pos = group[row['Player']]
                break

        if sender_pos:
            # Find potential receivers
            for group in positions.values():
                for receiver, receiver_pos in group.items():
                    if receiver == row['Player']:
                        continue  # Skip self

                    # Use math.dist to calculate distance
                    dist = math.dist(sender_pos, receiver_pos)
                    # Ensure that 'Diagonal Passes' and 'Square Passes' exist in the player_stats DataFrame
                    # These should be present due to the numeric_cols selection above.
                    diagonal_passes_mean = row.get('Diagonal Passes', 0) # Use .get with default 0 in case of missing data
                    square_passes_mean = row.get('Square Passes', 0)

                    pass_prob = (diagonal_passes_mean if abs(sender_pos[0]-receiver_pos[0]) != abs(sender_pos[1]-receiver_pos[1])
                                else square_passes_mean) / 100

                    # Adjust probability by distance
                    pass_prob *= 1/(dist+0.5)

                    if random.random() < pass_prob:
                        plt.plot([sender_pos[0], receiver_pos[0]],
                                [sender_pos[1], receiver_pos[1]],
                                'b-', alpha=0.3, linewidth=1)

    plt.title(f'Enhanced Passing Network for {team_name}\n(Key players highlighted)')
    plt.xlabel('Field Position (arbitrary units)')
    plt.ylabel('Field Position (arbitrary units)')
    plt.grid(True)
    plt.show()

# Generate enhanced passing networks
for team in enhanced_df['Team'].unique():
    visualize_team_passing_network(team)

"""#Machine Learning for Triangle Pattern Prediction

##1. Feature Engineering
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import random
import math
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
import xgboost as xgb

# Define real squads for each team
# Assuming team_squads is defined in a previous cell and that cell was run.
# If not, you need to include the definition of team_squads here or ensure that cell is run first.
team_squads = {
    "Klopp's Liverpool 2019": {
        'GK': ['Alisson'],
        'DEF': ['Virgil van Dijk', 'Trent Alexander-Arnold', 'Andrew Robertson', 'Joel Matip', 'Joe Gomez'],
        'MID': ['Jordan Henderson', 'Fabinho', 'Georginio Wijnaldum', 'James Milner', 'Naby Ke√Øta', 'Alex Oxlade-Chamberlain'],
        'FWD': ['Mohamed Salah', 'Sadio Man√©', 'Roberto Firmino', 'Xherdan Shaqiri', 'Divock Origi']
    },
    "Pep's Barcelona 2012": {
        'GK': ['Victor Vald√©s'],
        'DEF': ['Dani Alves', 'Gerard Piqu√©', 'Carles Puyol', 'Javier Mascherano', 'Eric Abidal'],
        'MID': ['Xavi', 'Andr√©s Iniesta', 'Sergio Busquets', 'Cesc F√†bregas', 'Thiago Alc√¢ntara'],
        'FWD': ['Lionel Messi', 'David Villa', 'Pedro', 'Alexis S√°nchez']
    },
    "Pep's Man City 2023": {
        'GK': ['Ederson'],
        'DEF': ['Kyle Walker', 'R√∫ben Dias', 'John Stones', 'Nathan Ak√©', 'Manuel Akanji'],
        'MID': ['Rodri', 'Kevin De Bruyne', 'ƒ∞lkay G√ºndoƒüan', 'Bernardo Silva', 'Jack Grealish'],
        'FWD': ['Erling Haaland', 'Phil Foden', 'Riyad Mahrez', 'Juli√°n √Ålvarez']
    }
}


def generate_enhanced_team_data(team_name, matches=10):
    """
    Generate enhanced passing data with real player names and position-specific patterns
    """
    data = []
    squad = team_squads[team_name]

    # Team style parameters
    if team_name == "Klopp's Liverpool 2019":
        style_params = {
            'DEF': {'diagonal': 18, 'square': 12, 'pass_length': 18},
            'MID': {'diagonal': 28, 'square': 15, 'pass_length': 12},
            'FWD': {'diagonal': 22, 'square': 10, 'pass_length': 14},
            'GK': {'diagonal': 10, 'square': 15, 'pass_length': 25},
            'triangle_factor': 0.8,
            'cutback_factor': 0.7
        }
    elif team_name == "Pep's Barcelona 2012":
        style_params = {
            'DEF': {'diagonal': 25, 'square': 8, 'pass_length': 15},
            'MID': {'diagonal': 45, 'square': 12, 'pass_length': 10},
            'FWD': {'diagonal': 30, 'square': 5, 'pass_length': 12},
            'GK': {'diagonal': 15, 'square': 10, 'pass_length': 20},
            'triangle_factor': 1.2,
            'cutback_factor': 0.9
        }
    elif team_name == "Pep's Man City 2023":
        style_params = {
            'DEF': {'diagonal': 22, 'square': 15, 'pass_length': 16},
            'MID': {'diagonal': 38, 'square': 20, 'pass_length': 11},
            'FWD': {'diagonal': 25, 'square': 12, 'pass_length': 13},
            'GK': {'diagonal': 12, 'square': 18, 'pass_length': 22},
            'triangle_factor': 1.1,
            'cutback_factor': 0.8
        }
    else:
        # Default parameters if team name not matched
        style_params = {
            'DEF': {'diagonal': 15, 'square': 10, 'pass_length': 16},
            'MID': {'diagonal': 20, 'square': 15, 'pass_length': 10},
            'FWD': {'diagonal': 18, 'square': 8, 'pass_length': 12},
            'GK': {'diagonal': 8, 'square': 12, 'pass_length': 20},
            'triangle_factor': 1.0,
            'cutback_factor': 0.5
        }


    # Generate data for each player
    for position_group, players in squad.items():
        for player in players:
            for match in range(1, matches + 1):
                params = style_params[position_group]

                # Generate pass counts with some randomness
                diagonal_passes = int(max(5, np.random.normal(params['diagonal'], 5)))
                square_passes = int(max(3, np.random.normal(params['square'], 3)))

                # Triangles formed based on diagonal passes
                triangles_formed = int(diagonal_passes * style_params['triangle_factor'] * np.random.uniform(0.8, 1.2) / 3)

                # Angle depends on position (midfielders create sharper angles)
                if position_group == 'MID':
                    avg_angle = np.random.normal(55, 5)
                else:
                    avg_angle = np.random.normal(65, 10)

                # Cutback goals (mostly for forwards and attacking mids)
                if position_group == 'FWD' or (position_group == 'MID' and player in ['Kevin De Bruyne', 'Andr√©s Iniesta']):
                    cutback_goals = int(np.random.poisson(style_params['cutback_factor'] * diagonal_passes / 15))
                else:
                    cutback_goals = 0

                # Shape efficiency metric
                shape_efficiency = (diagonal_passes * 1.5 + square_passes) / (diagonal_passes + square_passes + 1)

                data.append({
                    'Team': team_name,
                    'Player': player,
                    'Position': position_group,
                    'Match': match,
                    'Diagonal Passes': diagonal_passes,
                    'Square Passes': square_passes,
                    'Triangles Formed': triangles_formed,
                    'Avg Triangle Angle': avg_angle,
                    'Avg Pass Length': params['pass_length'] * np.random.uniform(0.9, 1.1),
                    'Cutback Goals': cutback_goals,
                    'Shape Efficiency': shape_efficiency,
                    'Key Player': 1 if player in [
                        'Virgil van Dijk', 'Trent Alexander-Arnold', 'Mohamed Salah', # Liverpool
                        'Xavi', 'Andr√©s Iniesta', 'Lionel Messi', # Barcelona
                        'Kevin De Bruyne', 'Rodri', 'Erling Haaland' # Man City
                    ] else 0
                })

    return pd.DataFrame(data)

# Generate enhanced data
enhanced_liverpool = generate_enhanced_team_data("Klopp's Liverpool 2019")
enhanced_barcelona = generate_enhanced_team_data("Pep's Barcelona 2012")
enhanced_mancity = generate_enhanced_team_data("Pep's Man City 2023")

# Combine all data
enhanced_df = pd.concat([enhanced_liverpool, enhanced_barcelona, enhanced_mancity], ignore_index=True)

# Calculate additional metrics
enhanced_df['Total Passes'] = enhanced_df['Diagonal Passes'] + enhanced_df['Square Passes']
enhanced_df['Triangle Ratio'] = enhanced_df['Triangles Formed'] / (enhanced_df['Total Passes'] + 0.001)
enhanced_df['Diagonal Pass %'] = enhanced_df['Diagonal Passes'] / enhanced_df['Total Passes']
enhanced_df['Triangle Side Length'] = enhanced_df['Avg Pass Length'] * 1.2

# --- Start of ML code ---
# Prepare the data for ML
def prepare_ml_data(df):
    # Create target variable - high triangle formation
    df['High_Triangle_Formation'] = (df['Triangle Ratio'] > df['Triangle Ratio'].median()).astype(int)

    # Select features
    features = [
        'Diagonal Passes', 'Square Passes', 'Avg Pass Length',
        'Position', 'Team', 'Avg Triangle Angle', 'Key Player'
    ]

    # Create feature dataframe
    X = df[features].copy()
    y = df['High_Triangle_Formation'].copy()

    # Encode categorical variables
    le = LabelEncoder()
    X['Position'] = le.fit_transform(X['Position'])
    X['Team'] = le.fit_transform(X['Team'])

    # Scale numerical features
    scaler = StandardScaler()
    num_cols = ['Diagonal Passes', 'Square Passes', 'Avg Pass Length', 'Avg Triangle Angle']
    X[num_cols] = scaler.fit_transform(X[num_cols])

    return X, y

# Now enhanced_df is guaranteed to be defined before this call
X, y = prepare_ml_data(enhanced_df)

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print(f"Training samples: {X_train.shape[0]}, Test samples: {X_test.shape[0]}")
print(f"Baseline accuracy: {max(y_test.mean(), 1 - y_test.mean()):.2f}")

"""##2. Model Training
Let's train several models to predict triangle patterns:
"""

def train_models(X_train, y_train):
    models = {
        "Random Forest": RandomForestClassifier(n_estimators=100, random_state=42),
        "Gradient Boosting": GradientBoostingClassifier(n_estimators=100, random_state=42),
        "XGBoost": xgb.XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42),
        "SVM": SVC(kernel='rbf', probability=True, random_state=42),
        "Neural Network": MLPClassifier(hidden_layer_sizes=(64, 32), max_iter=1000, random_state=42)
    }

    for name, model in models.items():
        model.fit(X_train, y_train)
        print(f"{name} trained")

    return models

models = train_models(X_train, y_train)

"""##3. Model Evaluation
Now let's evaluate our models
"""

# Import necessary libraries for plotting if they aren't guaranteed to be in scope
import matplotlib.pyplot as plt
import seaborn as sns

def evaluate_models(models, X_test, y_test):
    results = []

    for name, model in models.items():
        y_pred = model.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        report = classification_report(y_test, y_pred, output_dict=True)

        results.append({
            'Model': name,
            'Accuracy': accuracy,
            'Precision': report['weighted avg']['precision'],
            'Recall': report['weighted avg']['recall'],
            'F1': report['weighted avg']['f1-score']
        })

    return pd.DataFrame(results)

results_df = evaluate_models(models, X_test, y_test)
display(results_df.sort_values('Accuracy', ascending=False))

# Plot model performance
plt.figure(figsize=(12, 6))
sns.barplot(data=results_df, x='Model', y='Accuracy', palette='viridis')
plt.title('Model Performance Comparison')
plt.ylim(0.7, 1.0)
plt.xticks(rotation=45)
plt.show()

"""##4. Feature Importance Analysis
Let's see which features are most important for predicting triangle patterns:
"""

def plot_feature_importance(model, feature_names):
    if hasattr(model, 'feature_importances_'):
        importances = model.feature_importances_
    elif hasattr(model, 'coef_'):
        importances = np.abs(model.coef_[0])
    else:
        print("Model doesn't support feature importance directly")
        return

    indices = np.argsort(importances)[::-1]

    plt.figure(figsize=(10, 6))
    plt.title("Feature Importance")
    plt.bar(range(len(importances)), importances[indices], align='center')
    plt.xticks(range(len(importances)), [feature_names[i] for i in indices], rotation=45)
    plt.tight_layout()
    plt.show()

# Get best model
best_model = models[results_df.iloc[0]['Model']]
plot_feature_importance(best_model, X.columns)

"""##5. Tactical Pattern Prediction
Now let's create a function to predict triangle patterns for new scenarios
"""

def predict_triangle_pattern(model, player_data):
    """
    Predict whether a given player/situation will likely create triangles

    player_data: Dictionary containing:
        - 'Position': ['GK', 'DEF', 'MID', 'FWD']
        - 'Team': Team name
        - 'Diagonal Passes': int
        - 'Square Passes': int
        - 'Avg Pass Length': float
        - 'Avg Triangle Angle': float
        - 'Key Player': 0 or 1
    """
    # Create dataframe from input
    input_df = pd.DataFrame([player_data])

    # Encode categorical variables (must use same encoder as training)
    le_pos = LabelEncoder().fit(['GK', 'DEF', 'MID', 'FWD'])
    le_team = LabelEncoder().fit(enhanced_df['Team'].unique())

    input_df['Position'] = le_pos.transform(input_df['Position'])
    input_df['Team'] = le_team.transform(input_df['Team'])

    # Scale numerical features (using same scaler as training)
    scaler = StandardScaler().fit(enhanced_df[['Diagonal Passes', 'Square Passes', 'Avg Pass Length', 'Avg Triangle Angle']])
    num_cols = ['Diagonal Passes', 'Square Passes', 'Avg Pass Length', 'Avg Triangle Angle']
    input_df[num_cols] = scaler.transform(input_df[num_cols])

    # Ensure column order matches training
    input_df = input_df[X.columns]

    # Make prediction
    proba = model.predict_proba(input_df)[0]
    prediction = model.predict(input_df)[0]

    return {
        'probability_triangle': proba[1],
        'prediction': 'High Triangle Formation' if prediction == 1 else 'Low Triangle Formation'
    }

# Example prediction
example_player = {
    'Position': 'MID',
    'Team': "Pep's Barcelona 2012",
    'Diagonal Passes': 35,
    'Square Passes': 10,
    'Avg Pass Length': 12.5,
    'Avg Triangle Angle': 58,
    'Key Player': 1
}

prediction = predict_triangle_pattern(best_model, example_player)
print("\nExample Prediction:")
print(f"Player Profile: {example_player}")
print(f"Prediction: {prediction['prediction']} (Probability: {prediction['probability_triangle']:.2%})")

"""##6. Real-Time Triangle Detection System
Let's create a simulation for real-time triangle detection:
"""

def simulate_match_triangle_detection(model, team_name, match_duration=90):
    """
    Simulate triangle detection during a match
    """
    team_players = enhanced_df[(enhanced_df['Team'] == team_name) &
                             (enhanced_df['Match'] == 1)]  # Use first match data

    print(f"\nSimulating Triangle Detection for {team_name} (First {match_duration} minutes):")

    triangles_detected = 0
    time_intervals = np.arange(0, match_duration, 5)  # Check every 5 minutes

    for minute in time_intervals:
        # Randomly select 3 players involved in a potential triangle
        players = team_players.sample(3)

        # Calculate triangle probability (average of individual probabilities)
        player_probs = []
        for _, player in players.iterrows():
            player_data = {
                'Position': player['Position'],
                'Team': team_name,
                'Diagonal Passes': player['Diagonal Passes'],
                'Square Passes': player['Square Passes'],
                'Avg Pass Length': player['Avg Pass Length'],
                'Avg Triangle Angle': player['Avg Triangle Angle'],
                'Key Player': player['Key Player']
            }
            pred = predict_triangle_pattern(model, player_data)
            player_probs.append(pred['probability_triangle'])

        avg_prob = np.mean(player_probs)
        is_triangle = avg_prob > 0.65  # Threshold

        if is_triangle:
            triangles_detected += 1
            print(f"Min {minute}: Triangle detected between {players['Player'].tolist()} (Confidence: {avg_prob:.2%})")

    print(f"\nTotal triangles detected: {triangles_detected}")
    print(f"Average triangles per 15 mins: {triangles_detected / (match_duration / 15):.1f}")

# Simulate for each team
for team in enhanced_df['Team'].unique():
    simulate_match_triangle_detection(best_model, team)

"""##7. Tactical Recommendations Engine
let's create a system that provides tactical recommendations based on triangle predictions
"""

def generate_tactical_recommendations(team_name, opponent_data=None):
    """
    Generate recommendations to improve triangle formation
    """
    team_data = enhanced_df[enhanced_df['Team'] == team_name]

    # Analyze current triangle formation
    avg_ratio = team_data['Triangle Ratio'].mean()
    pos_analysis = team_data.groupby('Position')['Triangle Ratio'].mean()

    print(f"\nTactical Recommendations for {team_name}:")
    print(f"Current average triangle ratio: {avg_ratio:.2f}")

    # Position-specific recommendations
    for pos, ratio in pos_analysis.items():
        if ratio < pos_analysis.median():
            if pos == 'DEF':
                print(f"- Defenders: Create more diagonal passing options by having fullbacks push higher")
            elif pos == 'MID':
                print(f"- Midfielders: Improve positioning to form natural triangles (30-60 degree angles)")
            elif pos == 'FWD':
                print(f"- Forwards: Make more checking runs to complete attacking triangles")

    # General recommendations
    if avg_ratio < 0.25:
        print("\nSystemic Improvements Needed:")
        print("- Implement 3-player positional drills in training")
        print("- Adjust formation to create natural triangles (e.g., 4-3-3 instead of 4-4-2)")
        print("- Encourage third-man runs during build-up play")
    else:
        print("\nFine-Tuning Suggestions:")
        print("- Work on quick combination play in tight spaces")
        print("- Develop patterns to break lines using triangular movements")
        print("- Improve positional rotations to maintain triangle structures")

    # Opponent-specific adjustments
    if opponent_data:
        opp_avg_angle = opponent_data['Avg Triangle Angle'].mean()
        if opp_avg_angle < 55:
            print("\nOpponent Analysis:")
            print("- Opponent tends to form acute triangles - press the base player")
        elif opp_avg_angle > 65:
            print("\nOpponent Analysis:")
            print("- Opponent forms wide triangles - compact central spaces")

# Generate recommendations for each team
for team in enhanced_df['Team'].unique():
    generate_tactical_recommendations(team)

"""#Triangle Formation Predictor: User Input System
 user-friendly interface where coaches or analysts can input player/team data and get predictions about triangle formation likelihood.
"""

import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output
import pickle

# Load or train model (using the best model from previous analysis)
try:
    # Try loading saved model
    model = pickle.load(open('triangle_model.pkl', 'rb'))
    print("Loaded pre-trained model successfully!")
except:
    # Train model if not saved
    from sklearn.ensemble import RandomForestClassifier
    from sklearn.preprocessing import LabelEncoder

    # Simplified training for demo purposes
    X = enhanced_df[['Position', 'Team', 'Diagonal Passes', 'Square Passes', 'Avg Pass Length']]
    y = (enhanced_df['Triangle Ratio'] > enhanced_df['Triangle Ratio'].median()).astype(int)

    le = LabelEncoder()
    X['Position'] = le.fit_transform(X['Position'])
    X['Team'] = le.fit_transform(X['Team'])

    model = RandomForestClassifier(n_estimators=100, random_state=42)
    model.fit(X, y)
    pickle.dump(model, open('triangle_model.pkl', 'wb'))
    print("Trained new model successfully!")

# Define input widgets
team_dropdown = widgets.Dropdown(
    options=["Pep's Barcelona 2012", "Klopp's Liverpool 2019", "Pep's Man City 2023", "Other"],
    description='Team:',
    style={'description_width': '150px'}
)

position_dropdown = widgets.Dropdown(
    options=['GK', 'DEF', 'MID', 'FWD'],
    description='Position:',
    style={'description_width': '150px'}
)

diagonal_passes = widgets.IntSlider(
    value=15,
    min=0,
    max=60,
    step=1,
    description='Diagonal Passes:',
    style={'description_width': '150px'}
)

square_passes = widgets.IntSlider(
    value=10,
    min=0,
    max=50,
    step=1,
    description='Square Passes:',
    style={'description_width': '150px'}
)

avg_pass_length = widgets.FloatSlider(
    value=12.0,
    min=5.0,
    max=30.0,
    step=0.5,
    description='Avg Pass Length (m):',
    style={'description_width': '150px'}
)

key_player_toggle = widgets.ToggleButton(
    value=False,
    description='Key Player',
    tooltip='Is this a key player?',
    icon='check'
)

predict_button = widgets.Button(
    description='Predict Triangle Formation',
    button_style='success',
    tooltip='Click to make prediction'
)

output = widgets.Output()

# Suggested input fields with explanations
input_fields = widgets.VBox([
    widgets.HTML("<h3>Player/Team Input Parameters</h3>"),
    widgets.HTML("<i>Suggested fields based on model importance:</i>"),
    team_dropdown,
    position_dropdown,
    diagonal_passes,
    square_passes,
    avg_pass_length,
    widgets.HBox([widgets.Label(value="Key Player:"), key_player_toggle]),
    predict_button
])

# Prediction function
def on_predict_button_clicked(b):
    with output:
        clear_output()

        # Prepare input data
        input_data = {
            'Team': team_dropdown.value,
            'Position': position_dropdown.value,
            'Diagonal Passes': diagonal_passes.value,
            'Square Passes': square_passes.value,
            'Avg Pass Length': avg_pass_length.value,
            'Key Player': int(key_player_toggle.value)
        }

        # Create DataFrame
        input_df = pd.DataFrame([input_data])

        # Encode categorical variables
        le_pos = LabelEncoder().fit(['GK', 'DEF', 'MID', 'FWD'])
        le_team = LabelEncoder().fit(["Pep's Barcelona 2012", "Klopp's Liverpool 2019", "Pep's Man City 2023", "Other"])

        input_df['Position'] = le_pos.transform(input_df['Position'])
        input_df['Team'] = le_team.transform(input_df['Team'])

        # Ensure correct column order
        input_df = input_df[['Position', 'Team', 'Diagonal Passes', 'Square Passes', 'Avg Pass Length']]

        # Make prediction
        proba = model.predict_proba(input_df)[0][1]
        prediction = "HIGH" if proba > 0.5 else "LOW"

        # Display results
        print("\n" + "="*50)
        print(f"PREDICTION RESULTS".center(50))
        print("="*50)
        print(f"\nBased on the input parameters, this player/situation has:")
        print(f"\nüîπ Triangle Formation Probability: {proba:.1%}")
        print(f"üîπ Prediction: {prediction} likelihood of creating effective triangles")

        # Add tactical interpretation
        print("\n" + "="*50)
        print("TACTICAL INTERPRETATION".center(50))
        print("="*50)

        if prediction == "HIGH":
            print("\n‚úÖ Strong triangle formation potential detected")
            print("This player/situation is likely to:")
            print("- Create effective passing triangles")
            print("- Generate progressive passing options")
            print("- Break defensive lines effectively")

            if input_data['Position'] == 'MID':
                print("\nüí° Suggestion: Use as a pivot in midfield triangles")
            elif input_data['Position'] == 'DEF':
                print("\nüí° Suggestion: Initiate build-up play from this position")
        else:
            print("\n‚ö†Ô∏è Triangle formation potential appears limited")
            print("Consider improving:")
            print("- Diagonal passing options")
            print("- Positioning angles (30-60 degrees optimal)")
            print("- Third-man movement patterns")

            if input_data['Diagonal Passes'] < 15:
                print(f"\nüí° Suggestion: Increase diagonal passes (current: {input_data['Diagonal Passes']})")
            if input_data['Position'] == 'FWD':
                print("\nüí° Suggestion: Work on checking runs to complete attacking triangles")

        print("\n" + "="*50)

predict_button.on_click(on_predict_button_clicked)

# Display the interface
display(widgets.VBox([input_fields, output]))

"""##Advanced Triangle Formation Prediction System for Coaches
This enhanced system provides coaches and analysts with real-time tactical insights during training and matches. It now includes formation analysis, opponent scouting, and live adjustment recommendations.
"""

# Import necessary libraries
import pandas as pd
import ipywidgets as widgets
from IPython.display import display, clear_output
import pickle
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder, OneHotEncoder
import numpy as np
import os # Import os for file existence check

# Ensure scikit-learn is updated to a version that supports sparse_output
# If running in a new environment, you might need to install/upgrade:
# !pip install --upgrade scikit-learn

## 1. Enhanced Model Training with Formation Data
try:
    # Try loading saved model
    # Check if files exist before attempting to load
    if os.path.exists('advanced_triangle_model.pkl') and os.path.exists('formation_encoder.pkl') and os.path.exists('le_pos.pkl') and os.path.exists('le_team.pkl') and os.path.exists('model_features.pkl'):
        model = pickle.load(open('advanced_triangle_model.pkl', 'rb'))
        formation_encoder = pickle.load(open('formation_encoder.pkl', 'rb'))
        le_pos = pickle.load(open('le_pos.pkl', 'rb')) # Load encoders
        le_team = pickle.load(open('le_team.pkl', 'rb'))
        model_features = pickle.load(open('model_features.pkl', 'rb')) # Load feature names
        print("Loaded pre-trained models successfully!")
    else:
        print("Pre-trained models or encoders/feature names not found. Training new models...")
        raise FileNotFoundError # Explicitly raise to trigger the except block

except (FileNotFoundError, EOFError, pickle.UnpicklingError) as e:
    # Train model if not saved or loading failed
    print(f"Error loading models ({e}). Retraining...")

    # Enhanced training data with formations
    formations = ['4-3-3', '4-2-3-1', '3-4-3', '3-5-2', '4-4-2']
    # Add 'Formation' column only if it doesn't exist
    if 'Formation' not in enhanced_df.columns:
         # Ensure enhanced_df is defined before trying to add a column
         try:
             enhanced_df
         except NameError:
              # Define a minimal team_squads if it's also not defined
              try:
                   team_squads
              except NameError:
                   team_squads = {
                       "Sample Team": {
                           'DEF': ['D1'], 'MID': ['M1'], 'FWD': ['F1']
                       }
                   }
              # Regenerate a minimal enhanced_df
              enhanced_df = generate_enhanced_team_data("Sample Team", matches=2)
              # Ensure it has the needed columns
              enhanced_df['Total Passes'] = enhanced_df['Diagonal Passes'] + enhanced_df['Square Passes']
              enhanced_df['Triangle Ratio'] = enhanced_df['Triangles Formed'] / (enhanced_df['Total Passes'] + 0.001)
              enhanced_df['Avg Triangle Angle'] = np.random.normal(60, 10, size=len(enhanced_df))
              if 'Key Player' not in enhanced_df.columns:
                   enhanced_df['Key Player'] = 0

         # Now add the Formation column
         enhanced_df['Formation'] = np.random.choice(formations, size=len(enhanced_df))


    # Prepare features
    # Ensure enhanced_df and its required columns ('Position', 'Team', etc.) are defined
    # before this block is executed. Assumes enhanced_df comes from a previous cell.

    # Select only numeric columns and relevant others before creating X
    # Ensure all required columns exist before selection
    required_cols_for_X = ['Position', 'Team', 'Diagonal Passes', 'Square Passes', 'Avg Pass Length']
    # Add other potential numerical features if they exist and are desired as features
    optional_num_cols = ['Avg Triangle Angle', 'Key Player', 'Total Passes', 'Triangle Ratio', 'Diagonal Pass %', 'Triangle Side Length', 'Cutback Goals', 'Shape Efficiency']
    for col in optional_num_cols:
        if col in enhanced_df.columns and col not in required_cols_for_X:
            required_cols_for_X.append(col)

    # Filter for columns that are actually in enhanced_df
    actual_feature_cols = [col for col in required_cols_for_X if col in enhanced_df.columns]


    if not all(col in enhanced_df.columns for col in ['Position', 'Team', 'Diagonal Passes', 'Square Passes', 'Avg Pass Length', 'Formation']):
         # Handle critical missing columns after potential regeneration
         print("Error: Critical columns for training not found in enhanced_df after regeneration attempt.")
         # You might want to exit or handle this more gracefully
         raise SystemExit("Missing required data columns for training.")


    X = enhanced_df[actual_feature_cols].copy() # Use .copy() to avoid SettingWithCopyWarning
    y = (enhanced_df['Triangle Ratio'] > enhanced_df['Triangle Ratio'].median()).astype(int).copy() # Use .copy()

    # Train formation encoder
    formation_encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore') # Add handle_unknown
    formation_encoded = formation_encoder.fit_transform(enhanced_df[['Formation']])
    # Get string feature names from the encoder
    formation_feature_names = formation_encoder.get_feature_names_out(['Formation'])
    # Ensure the DataFrame columns from OneHotEncoder are strings
    formation_encoded_df = pd.DataFrame(formation_encoded, index=X.index, columns=formation_feature_names)

    # Use reset_index if indices don't align
    if not X.index.equals(formation_encoded_df.index):
        X = X.reset_index(drop=True)
        formation_encoded_df = formation_encoded_df.reset_index(drop=True)

    X = pd.concat([X, formation_encoded_df], axis=1)


    # Encode categoricals - fit on the full possible categories if needed
    le_pos = LabelEncoder()
    # Fit on all unique values from data + potential future ones from dropdown
    all_possible_positions = list(enhanced_df['Position'].unique()) + ['CB', 'FB/WB', 'DM', 'CM', 'AM', 'W', 'ST']
    le_pos.fit(list(set(all_possible_positions))) # Fit on unique list
    X['Position'] = le_pos.transform(X['Position'])

    le_team = LabelEncoder()
     # Fit on all unique values from data + potential future ones from dropdown
    all_possible_teams = list(enhanced_df['Team'].unique()) + ["Pep's Barcelona 2012", "Klopp's Liverpool 2019", "Pep's Man City 2023", "Other", "Custom"]
    le_team.fit(list(set(all_possible_teams))) # Fit on unique list
    X['Team'] = le_team.transform(X['Team'])

    # --- FIX: Ensure all column names are strings ---
    X.columns = X.columns.astype(str)
    # --- END FIX ---

    # Train model
    model = RandomForestClassifier(n_estimators=200, random_state=42)
    model.fit(X, y)

    # Save models and encoders and feature names
    try:
        pickle.dump(model, open('advanced_triangle_model.pkl', 'wb'))
        pickle.dump(formation_encoder, open('formation_encoder.pkl', 'wb'))
        pickle.dump(le_pos, open('le_pos.pkl', 'wb')) # Save encoders
        pickle.dump(le_team, open('le_team.pkl', 'wb'))
        pickle.dump(X.columns.tolist(), open('model_features.pkl', 'wb')) # Save feature names
        print("Trained and saved new models successfully!")
    except Exception as save_error:
        print(f"Warning: Could not save models. Error: {save_error}")


## 2. Interactive Coach Dashboard
# Formations with tactical descriptions
formation_info = {
    '4-3-3': "Creates natural triangles in midfield and wide areas",
    '4-2-3-1': "Strong central triangle with double pivot",
    '3-4-3': "Wing-back triangles with front three connections",
    '3-5-2': "Midfield overload with box midfield options",
    '4-4-2': "Limited triangles - requires diagonal fullback support"
}

# Create widgets
style = {'description_width': '180px'}
layout = widgets.Layout(width='300px')

# Section 1: Team Setup
team_dropdown = widgets.Dropdown(
    options=le_team.classes_.tolist(), # Use classes from the loaded/trained encoder
    description='Team Style:', style=style, layout=layout
)

formation_dropdown = widgets.Dropdown(
    options=list(formation_info.keys()), # Use keys from info dict
    description='Formation:', style=style, layout=layout
)

formation_info_out = widgets.Output()

def update_formation_info(change):
    with formation_info_out:
        clear_output()
        print(f"Tactical Properties:\n{formation_info.get(change.new, 'Description not available')}") # Use .get() for safety

formation_dropdown.observe(update_formation_info, names='value')

# Section 2: Player Input
player_name = widgets.Text(description='Player Name:', style=style, layout=layout)
position_dropdown = widgets.Dropdown(
    options=le_pos.classes_.tolist(), # Use classes from the loaded/trained encoder
    description='Position:', style=style, layout=layout
)

diagonal_passes = widgets.IntSlider(
    value=15, min=0, max=60, step=1,
    description='Diagonal Passes/Game:', style=style
)

square_passes = widgets.IntSlider(
    value=10, min=0, max=50, step=1,
    description='Square Passes/Game:', style=style
)

avg_pass_length = widgets.FloatSlider(
    value=12.0, min=5.0, max=30.0, step=0.5,
    description='Avg Pass Length (m):', style=style
)

key_player_toggle = widgets.ToggleButtons( # Renamed from key_player to avoid conflict
    options=[('Regular', 0), ('Key Player', 1)],
    description='Player Status:', style=style
)

# Section 3: Match Context
match_scenario = widgets.Dropdown(
    options=['Build-Up', 'Final Third', 'Transition', 'High Press', 'Low Block'],
    description='Game Phase:', style=style, layout=layout
)

opponent_formation = widgets.Dropdown(
    options=list(formation_info.keys()) + ['Unknown'],
    description='Opponent Formation:', style=style, layout=layout
)

# Section 4: Analysis Buttons
analyze_player = widgets.Button(
    description='Analyze Player',
    button_style='info',
    tooltip='Evaluate individual impact on triangles'
)

analyze_team = widgets.Button(
    description='Team Tactical Report',
    button_style='warning',
    tooltip='Generate formation-based recommendations'
)

counter_opponent = widgets.Button(
    description='Opponent Counter Plan',
    button_style='danger',
    tooltip='Develop strategies to disrupt opponent triangles'
)

output = widgets.Output()

## 3. Analysis Functions
# Load encoders and feature names if models were loaded (already done in try block)
# Ensure model_features is available - potentially load if loading failed
try:
    model_features
except NameError:
    print("model_features not defined. Attempting to load from file or create fallback.")
    try:
        model_features = pickle.load(open('model_features.pkl', 'rb'))
        le_pos = pickle.load(open('le_pos.pkl', 'rb')) # Load encoders if not already loaded
        le_team = pickle.load(open('le_team.pkl', 'rb'))
        formation_encoder = pickle.load(open('formation_encoder.pkl', 'rb'))
    except:
        # Fallback if loading fails
        print("Could not load model_features, encoders, or formation_encoder. Prediction might fail.")
        # Define a minimal set of features and encoders for basic functionality
        model_features = ['Position', 'Team', 'Diagonal Passes', 'Square Passes', 'Avg Pass Length', 'Formation_4-3-3', 'Formation_4-2-3-1', 'Formation_3-4-3', 'Formation_3-5-2', 'Formation_4-4-2']
        le_pos = LabelEncoder().fit(['GK', 'DEF', 'MID', 'FWD', 'CB', 'FB/WB', 'DM', 'CM', 'AM', 'W', 'ST'])
        le_team = LabelEncoder().fit(["Pep's Barcelona 2012", "Klopp's Liverpool 2019", "Pep's Man City 2023", "Other", "Custom", "Sample Team"])
        # Create a dummy formation_encoder if it couldn't be loaded
        class DummyFormationEncoder:
            def transform(self, X):
                # Create a dummy one-hot encoded output matching model_features formation cols
                formations = list(formation_info.keys())
                output = np.zeros((X.shape[0], len(formations)))
                for i, form in enumerate(X.iloc[:, 0]):
                    try:
                         idx = formations.index(form)
                         output[i, idx] = 1
                    except ValueError:
                         # Handle unknown formation - defaults to all zeros for that row
                         pass
                return output

            def get_feature_names_out(self, input_features):
                 return [f"{input_features[0]}_{f}" for f in list(formation_info.keys())]

        formation_encoder = DummyFormationEncoder()


def predict_triangle_probability(inputs):
    """Core prediction function"""
    # Create input DataFrame
    input_df = pd.DataFrame([inputs])

    # Encode categorical variables using the loaded/trained encoders
    # Ensure the position/team value is one the encoder expects or handle unknown
    all_positions = le_pos.classes_
    all_teams = le_team.classes_

    input_df['Position'] = input_df['Position'].apply(lambda x: x if x in all_positions else all_positions[0]) # Fallback to first known position
    input_df['Team'] = input_df['Team'].apply(lambda x: x if x in all_teams else all_teams[0]) # Fallback to first known team

    input_df['Position'] = le_pos.transform(input_df['Position'])
    input_df['Team'] = le_team.transform(input_df['Team'])

    # Encode formation using the loaded/trained encoder
    # Ensure the formation value is one the encoder expects, or handle it
    all_encoder_formations = [col.replace('Formation_', '') for col in formation_encoder.get_feature_names_out(['Formation'])]
    if inputs['Formation'] not in all_encoder_formations:
        print(f"Warning: Formation '{inputs['Formation']}' not seen during training. Using first available for encoding.")
        # Replace with a known formation or handle as unknown if encoder supports it
        known_formation = all_encoder_formations[0] if all_encoder_formations else list(formation_info.keys())[0]
        temp_formation_df = pd.DataFrame([known_formation], columns=['Formation'])
    else:
         temp_formation_df = pd.DataFrame([inputs['Formation']], columns=['Formation'])


    formation_encoded = formation_encoder.transform(temp_formation_df)
    formation_feature_names = formation_encoder.get_feature_names_out(['Formation'])
    formation_encoded_df = pd.DataFrame(formation_encoded, index=input_df.index, columns=formation_feature_names)


    # Drop the original 'Formation' column from input_df before concat if it exists
    if 'Formation' in input_df.columns:
        input_df = input_df.drop('Formation', axis=1)

    # Add KeyPlayer column if not present and in model features
    if 'Key Player' not in input_df.columns and 'Key Player' in model_features:
         input_df['Key Player'] = inputs.get('KeyPlayer', 0) # Use .get for safety

    # Combine encoded features
    # Ensure indices align - typically fine if using pd.DataFrame([inputs])
    input_df = pd.concat([input_df, formation_encoded_df], axis=1)

    # --- FIX: Ensure all column names are strings before aligning with model_features ---
    input_df.columns = input_df.columns.astype(str)
    # --- END FIX ---


    # Ensure correct column order and handle missing/extra features
    final_input_df = pd.DataFrame(0.0, index=input_df.index, columns=model_features) # Use float for safety with scaling later

    for col in input_df.columns:
        if col in final_input_df.columns:
            final_input_df[col] = input_df[col].values # Use .values to avoid index alignment issues if shapes match
        else:
             print(f"Warning: Input column '{col}' not in model features. Ignoring.")

    # Ensure all model features are present (added with default 0.0 already)
    # No need to explicitly add missing_cols, they are already in final_input_df with 0.0

    # Reorder columns to match training data
    final_input_df = final_input_df[model_features]

    # Make prediction
    # Ensure the model is loaded before calling predict_proba
    try:
        model
    except NameError:
        print("Error: Model not loaded or trained.")
        return 0.5 # Return neutral probability as fallback


    return model.predict_proba(final_input_df)[0][1]


def analyze_player_clicked(b):
    with output:
        clear_output()
        # Collect inputs, using key_player_toggle.value
        inputs = {
            'Team': team_dropdown.value,
            'Position': position_dropdown.value,
            'Diagonal Passes': diagonal_passes.value,
            'Square Passes': square_passes.value,
            'Avg Pass Length': avg_pass_length.value,
            'Formation': formation_dropdown.value,
            'KeyPlayer': key_player_toggle.value # Use the correct widget name
        }

        try:
            proba = predict_triangle_probability(inputs)

            print(f"üßë‚öΩ PLAYER ANALYSIS: {player_name.value}")
            print("="*50)
            print(f"üîπ Triangle Formation Probability: {proba:.1%}")
            print(f"üîπ Positional Impact: {position_dropdown.value}")
            print(f"üîπ Key Contribution: {'Yes' if key_player_toggle.value else 'No'}") # Use the correct widget name

            # Tactical advice
            if proba > 0.7:
                print("\n‚úÖ EXCELLENT TRIANGLE GENERATOR")
                print("This player should be:")
                print("- Used as a pivot in build-up play")
                print("- Positioned at the base of triangles")
                if inputs['Position'] in ['FB/WB', 'W']: # Use inputs dict
                    print("- Encouraged to make underlapping runs")
            elif proba > 0.5:
                print("\nüü° MODERATE TRIANGLE CONTRIBUTOR")
                print("Improvement suggestions:")
                print("- Work on diagonal passing accuracy")
                print("- Adjust positioning to create better angles")
                if inputs['Position'] in ['CB', 'DM']: # Use inputs dict
                    print("- Practice line-breaking passes")
            else:
                print("\nüî¥ LIMITED TRIANGLE IMPACT")
                print("Recommended adjustments:")
                print("- Specific triangle formation drills")
                print(f"- Reduce square passes (current: {inputs['Square Passes']})") # Use inputs dict
                if inputs['Position'] == 'ST': # Use inputs dict
                    print("- Practice checking runs to link play")
        except Exception as e:
            print(f"Error during player analysis: {e}")
            import traceback
            traceback.print_exc()


def analyze_team_clicked(b):
    with output:
        clear_output()
        print(f"üìä TEAM TACTICAL REPORT: {formation_dropdown.value} Formation")
        print("="*50)

        # Simulate analysis for different positions
        # Ensure these positions are compatible with the encoder
        positions_to_simulate = [pos for pos in ['GK', 'CB', 'FB/WB', 'DM', 'CM', 'AM', 'W', 'ST', 'DEF', 'MID', 'FWD'] if pos in le_pos.classes_]

        if not positions_to_simulate:
            print("Error: No valid positions found for simulation based on the trained encoder.")
            return

        avg_proba = 0
        position_data = []

        for pos in positions_to_simulate:
            # Create a placeholder input for simulation - needs adjustment based on typical stats for position/formation
            # These values are placeholders and might need tuning
            # Example: Adjust base stats based on position group (DEF, MID, FWD, GK) and team style if needed
            # This is a simplification; a more complex simulation could sample from team-specific positional data
            base_diagonal = 20
            base_square = 15
            base_pass_length = 12

            if pos in ['GK', 'CB', 'DEF']:
                base_diagonal = 15
                base_square = 10
                base_pass_length = 20
            elif pos in ['DM', 'CM', 'AM', 'MID']:
                base_diagonal = 30
                base_square = 15
                base_pass_length = 12
            elif pos in ['W', 'ST', 'FWD']:
                base_diagonal = 25
                base_square = 8
                base_pass_length = 14

            # Add some randomness
            diag = int(max(0, np.random.normal(base_diagonal, 5)))
            sq = int(max(0, np.random.normal(base_square, 3)))
            length = np.random.normal(base_pass_length, 3)


            inputs = {
                'Team': team_dropdown.value, # Use selected team
                'Position': pos,
                'Diagonal Passes': diag,
                'Square Passes': sq,
                'Avg Pass Length': length,
                'Formation': formation_dropdown.value,
                'KeyPlayer': 0 # Assume not a key player for general position analysis
            }
            try:
                 proba = predict_triangle_probability(inputs)
                 avg_proba += proba
                 position_data.append((pos, proba))
            except Exception as e:
                 print(f"Warning: Could not simulate probability for position {pos}. Error: {e}")
                 import traceback
                 traceback.print_exc()


        if position_data:
            avg_proba /= len(position_data)

            # Formation strengths
            print(f"\nOverall Triangle Formation Score: {avg_proba:.1%}")
            print("\nPositional Breakdown:")
            # Sort positions by probability for better readability
            position_data_sorted = sorted(position_data, key=lambda x: x[1], reverse=True)
            for pos, proba in position_data_sorted:
                print(f"- {pos}: {proba:.1%}")

            # Formation-specific advice
            print("\nüîß FORMATION OPTIMIZATION:")
            if formation_dropdown.value == '4-3-3':
                print("- Strengthen midfield triangle with proper spacing")
                print("- Fullbacks should provide width to stretch play")
            elif formation_dropdown.value == '3-5-2':
                print("- Create diamond shapes in midfield")
                print("- Use wingbacks to form wide triangles")
            elif formation_dropdown.value == '4-2-3-1': # Add advice for other formations
                 print("- Ensure double pivot maintains connectivity")
                 print("- Link #10 with wide players and striker")
            elif formation_dropdown.value == '3-4-3':
                 print("- Maintain width with wingbacks")
                 print("- Connect midfield two with the front three")
            elif formation_dropdown.value == '4-4-2':
                 print("- Requires significant diagonal movement from midfielders/fullbacks")
                 print("- Strikers need to drop to link play")
            else: # Default advice for 'Custom' or unknown
                 print("- Focus on player spacing to create natural triangles")
                 print("- Practice quick passing sequences involving three players")


            # Weakness diagnosis
            if position_data_sorted:
                 weak_pos = position_data_sorted[-1][0] # The one with lowest probability
                 print(f"\nüö® WEAKEST AREA: {weak_pos}")
                 if weak_pos in ['CB', 'DEF']:
                     print("- Improve diagonal distribution from backline")
                 elif weak_pos in ['W', 'FB/WB']:
                     print("- Work on combination play in wide channels")
                 elif weak_pos in ['DM', 'CM', 'AM', 'MID']:
                     print("- Focus on quick central combinations and breaking lines")
                 elif weak_pos in ['ST', 'FWD']:
                     print("- Practice checking runs and linking play with midfield")

        else:
             print("Could not generate positional breakdown.")


def counter_opponent_clicked(b):
    with output:
        clear_output()
        print(f"üõ°Ô∏è OPPONENT COUNTER PLAN: {opponent_formation.value}")
        print("="*50)

        # Common opponent formations and how to counter
        counter_strategies = {
            '4-3-3': [
                "Press their single pivot (DM)",
                "Force play wide and compact central areas",
                "Use your fullbacks to mark their wingers"
            ],
            '3-5-2': [
                "Exploit channels behind wingbacks",
                "Overload central midfield 3v2",
                "Prevent switches of play to weak side"
            ],
            '4-2-3-1': [
                "Isolate their #10 from build-up",
                "Double-team their wingers",
                "Exploit space between lines"
            ],
             '4-4-2': [ # Added counter for 4-4-2
                 "Target space between defensive and midfield lines",
                 "Circulate the ball quickly to shift their block",
                 "Overload flanks to create crossing opportunities"
             ],
            '3-4-3': [ # Added counter for 3-4-3
                "Press center backs when they receive the ball",
                "Block passing lanes to wingbacks",
                "Prevent their front three from combining centrally"
            ]
        }

        if opponent_formation.value in counter_strategies:
            print("\nüîç RECOMMENDED COUNTER MEASURES:")
            for i, strategy in enumerate(counter_strategies[opponent_formation.value], 1):
                print(f"{i}. {strategy}")

            print("\nüí° TRIANGLE DISRUPTION TACTICS:")
            print("- Use staggered pressing to break their triangles")
            print("- Position interceptors in passing lanes")
            if opponent_formation.value == '4-3-3':
                print("- Have your wingers track their fullbacks")
            elif opponent_formation.value == '3-5-2':
                 print("- Press the two central strikers simultaneously")
            else:
                 print("- Identify key opponent players who initiate triangles and limit their space.")


        else:
            print("\n‚ö†Ô∏è No specific counter plan available for this formation.")
            print("General triangle disruption tactics:")
            print("- Compact vertical space between lines (reduce space for passes)")
            print("- Force play toward predictable areas (e.g., sidelines)")
            print("- Deny key players time and space")


        # Suggested defensive adjustments
        print("\nüîß SUGGESTED FORMATION ADJUSTMENT:")
        recommended_counter_formation = get_counter_formation(opponent_formation.value)
        print(f"- Consider switching to a {recommended_counter_formation} formation.")
        # Added more specific marking advice
        if opponent_formation.value == '4-3-3':
             print("- Assign a dedicated marker to the opponent's #6 (defensive midfielder).")
        elif opponent_formation.value == '4-2-3-1':
             print("- Focus marking on the opponent's #10 (attacking midfielder).")
        elif opponent_formation.value == '3-5-2':
             print("- Your central defenders should closely track their two strikers.")
        elif opponent_formation.value in ['3-4-3', '4-4-2']:
             print("- Ensure your central midfielders track forward runs from opponent midfielders.")
        else:
             print("- Assign man-marking on their key triangle players (e.g., central midfielders, false 9s).")

        print("- Adjust defensive line height (high press vs. low block) based on their build-up style.")


def get_counter_formation(opp_formation):
    """Suggest optimal counter formation"""
    counter_formations = {
        '4-3-3': '4-2-3-1',
        '3-5-2': '4-4-2',
        '4-2-3-1': '4-3-3',
        '4-4-2': '4-3-3', # 4-3-3 can counter 4-4-2 central overload
        '3-4-3': '4-4-2' # 4-4-2 solid block can counter 3-4-3 width
    }
    # Default counter if opponent formation is unknown or not in map
    return counter_formations.get(opp_formation, '4-1-4-1')


## 4. Assemble the Dashboard
analyze_player.on_click(analyze_player_clicked)
analyze_team.on_click(analyze_team_clicked)
counter_opponent.on_click(counter_opponent_clicked)

# Create tabbed interface
tab_nest = widgets.Tab()
tab_nest.children = [
    widgets.VBox([
        widgets.HTML("<h2>Player Analysis</h2>"),
        player_name,
        position_dropdown,
        diagonal_passes,
        square_passes,
        avg_pass_length,
        key_player_toggle, # Use the correct widget name
        analyze_player
    ]),
    widgets.VBox([
        widgets.HTML("<h2>Team Setup</h2>"),
        team_dropdown,
        formation_dropdown,
        formation_info_out,
        widgets.HTML("<h3>Match Context</h3>"),
        match_scenario,
        analyze_team
    ]),
    widgets.VBox([
        widgets.HTML("<h2>Opponent Analysis</h2>"),
        opponent_formation,
        widgets.HTML("<h3>Counter Strategies</h3>"),
        counter_opponent
    ])
]

tab_nest.titles = ["Individual Player", "Team Tactics", "Opponent Scout"]
display(widgets.VBox([tab_nest, output]))

from google.colab import files

# Convert the dataframe to a CSV string
csv_data = enhanced_df.to_csv(index=False)

# Create a dummy file to trigger the download
with open('enhanced_dataframe.csv', 'w') as f:
  f.write(csv_data)

# Download the file
files.download('enhanced_dataframe.csv')

# Import necessary libraries within this cell scope if it might be run independently
import pandas as pd
import numpy as np # Explicitly import numpy here
import random

# Define real squads for each team (assuming this was run before this cell)
# team_squads = { ... } # This variable needs to be defined before calling generate_enhanced_team_data
team_squads = {
    "Klopp's Liverpool 2019": {
        'GK': ['Alisson'],
        'DEF': ['Virgil van Dijk', 'Trent Alexander-Arnold', 'Andrew Robertson', 'Joel Matip', 'Joe Gomez'],
        'MID': ['Jordan Henderson', 'Fabinho', 'Georginio Wijnaldum', 'James Milner', 'Naby Ke√Øta', 'Alex Oxlade-Chamberlain'],
        'FWD': ['Mohamed Salah', 'Sadio Man√©', 'Roberto Firmino', 'Xherdan Shaqiri', 'Divock Origi']
    },
    "Pep's Barcelona 2012": {
        'GK': ['Victor Vald√©s'],
        'DEF': ['Dani Alves', 'Gerard Piqu√©', 'Carles Puyol', 'Javier Mascherano', 'Eric Abidal'],
        'MID': ['Xavi', 'Andr√©s Iniesta', 'Sergio Busquets', 'Cesc F√†bregas', 'Thiago Alc√¢ntara'],
        'FWD': ['Lionel Messi', 'David Villa', 'Pedro', 'Alexis S√°nchez']
    },
    "Pep's Man City 2023": {
        'GK': ['Ederson'],
        'DEF': ['Kyle Walker', 'R√∫ben Dias', 'John Stones', 'Nathan Ak√©', 'Manuel Akanji'],
        'MID': ['Rodri', 'Kevin De Bruyne', 'ƒ∞lkay G√ºndoƒüan', 'Bernardo Silva', 'Jack Grealish'],
        'FWD': ['Erling Haaland', 'Phil Foden', 'Riyad Mahrez', 'Juli√°n √Ålvarez']
    }
}

def generate_enhanced_team_data(team_name, matches=10):
    """
    Generate enhanced passing data with real player names and position-specific patterns
    """
    data = []
    squad = team_squads[team_name]

    # Team style parameters
    if team_name == "Klopp's Liverpool 2019":
        style_params = {
            'DEF': {'diagonal': 18, 'square': 12, 'pass_length': 18},
            'MID': {'diagonal': 28, 'square': 15, 'pass_length': 12},
            'FWD': {'diagonal': 22, 'square': 10, 'pass_length': 14},
            'GK': {'diagonal': 10, 'square': 15, 'pass_length': 25},
            'triangle_factor': 0.8,
            'cutback_factor': 0.7
        }
    elif team_name == "Pep's Barcelona 2012":
        style_params = {
            'DEF': {'diagonal': 25, 'square': 8, 'pass_length': 15},
            'MID': {'diagonal': 45, 'square': 12, 'pass_length': 10},
            'FWD': {'diagonal': 30, 'square': 5, 'pass_length': 12},
            'GK': {'diagonal': 15, 'square': 10, 'pass_length': 20},
            'triangle_factor': 1.2,
            'cutback_factor': 0.9
        }
    elif team_name == "Pep's Man City 2023":
        style_params = {
            'DEF': {'diagonal': 22, 'square': 15, 'pass_length': 16},
            'MID': {'diagonal': 38, 'square': 20, 'pass_length': 11},
            'FWD': {'diagonal': 25, 'square': 12, 'pass_length': 13},
            'GK': {'diagonal': 12, 'square': 18, 'pass_length': 22},
            'triangle_factor': 1.1,
            'cutback_factor': 0.8
        }
    else:
        # Default parameters if team name not matched
        style_params = {
            'DEF': {'diagonal': 15, 'square': 10, 'pass_length': 16},
            'MID': {'diagonal': 20, 'square': 15, 'pass_length': 10},
            'FWD': {'diagonal': 18, 'square': 8, 'pass_length': 12},
            'GK': {'diagonal': 8, 'square': 12, 'pass_length': 20},
            'triangle_factor': 1.0,
            'cutback_factor': 0.5
        }


    # Generate data for each player
    for position_group, players in squad.items():
        for player in players:
            for match in range(1, matches + 1):
                params = style_params[position_group]

                # Generate pass counts with some randomness
                diagonal_passes = int(max(5, np.random.normal(params['diagonal'], 5)))
                square_passes = int(max(3, np.random.normal(params['square'], 3)))

                # Triangles formed based on diagonal passes
                triangles_formed = int(diagonal_passes * style_params['triangle_factor'] * np.random.uniform(0.8, 1.2) / 3)

                # Angle depends on position (midfielders create sharper angles)
                if position_group == 'MID':
                    avg_angle = np.random.normal(55, 5)
                else:
                    avg_angle = np.random.normal(65, 10)

                # Cutback goals (mostly for forwards and attacking mids)
                if position_group == 'FWD' or (position_group == 'MID' and player in ['Kevin De Bruyne', 'Andr√©s Iniesta']):
                    cutback_goals = int(np.random.poisson(style_params['cutback_factor'] * diagonal_passes / 15))
                else:
                    cutback_goals = 0

                # Shape efficiency metric
                shape_efficiency = (diagonal_passes * 1.5 + square_passes) / (diagonal_passes + square_passes + 1)

                data.append({
                    'Team': team_name,
                    'Player': player,
                    'Position': position_group,
                    'Match': match,
                    'Diagonal Passes': diagonal_passes,
                    'Square Passes': square_passes,
                    'Triangles Formed': triangles_formed,
                    'Avg Triangle Angle': avg_angle,
                    'Avg Pass Length': params['pass_length'] * np.random.uniform(0.9, 1.1),
                    'Cutback Goals': cutback_goals,
                    'Shape Efficiency': shape_efficiency,
                    'Key Player': 1 if player in [
                        'Virgil van Dijk', 'Trent Alexander-Arnold', 'Mohamed Salah', # Liverpool
                        'Xavi', 'Andr√©s Iniesta', 'Lionel Messi', # Barcelona
                        'Kevin De Bruyne', 'Rodri', 'Erling Haaland' # Man City
                    ] else 0
                })

    return pd.DataFrame(data)

# Generate enhanced data
enhanced_liverpool = generate_enhanced_team_data("Klopp's Liverpool 2019")
enhanced_barcelona = generate_enhanced_team_data("Pep's Barcelona 2012")
enhanced_mancity = generate_enhanced_team_data("Pep's Man City 2023")

# Combine all data
enhanced_df = pd.concat([enhanced_liverpool, enhanced_barcelona, enhanced_mancity], ignore_index=True)

# Calculate additional metrics
enhanced_df['Total Passes'] = enhanced_df['Diagonal Passes'] + enhanced_df['Square Passes']
enhanced_df['Triangle Ratio'] = enhanced_df['Triangles Formed'] / (enhanced_df['Total Passes'] + 0.001)
enhanced_df['Diagonal Pass %'] = enhanced_df['Diagonal Passes'] / enhanced_df['Total Passes']
enhanced_df['Triangle Side Length'] = enhanced_df['Avg Pass Length'] * 1.2

# Display sample
display(enhanced_df.sample(10))

from google.colab import files

# Convert the dataframe to a CSV string
csv_data = enhanced_df.to_csv(index=False)

# Create a dummy file to trigger the download
with open('enhanced_dataframe.csv', 'w') as f:
  f.write(csv_data)

# Download the file
files.download('enhanced_dataframe.csv')